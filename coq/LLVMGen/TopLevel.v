Require Import Helix.LLVMGen.Correctness_Prelude.
Require Import Helix.LLVMGen.EvalDenoteEquiv.
Require Import Helix.DynWin.DynWinProofs.
Require Import Helix.LLVMGen.Correctness_GenIR.
Require Import Helix.LLVMGen.Init.
Require Import Helix.LLVMGen.Correctness_Invariants.

Import ReifyAHCOL.
Import AHCOLtoRHCOL.
Import ReifyRHCOL.
Import RHCOLtoFHCOL.
Import RSigmaHCOL.
Import RHCOL.
Import AHCOLtoRHCOL.
Import DynWin.
Import RHCOLtoFHCOL.
Import RHCOLEval.
Import FHCOLEval.
Import CarrierType.

Import SemNotations.
Import BidBound.

Lemma top_to_FHCOL :
  (* ?? *)
  orders.SemiRingOrder CarrierAle →

  (* ?? *)
  ∀ (AR_CHE : AHCOLtoRHCOL.CTranslation_heq)
    (AR_CTO : AHCOLtoRHCOL.CTranslationOp),

    AHCOLtoRHCOL.CTranslationOp_strict →
    AHCOLtoRHCOL.COpTranslationProps →

    (* ?? *)
    ∀ (RF_CHE : RHCOLtoFHCOL.CTranslation_heq)
      (RF_CTO : RHCOLtoFHCOL.CTranslationOp)

      (a : Vector.t CarrierA 3) (* parameter *)
      (x : Vector.t CarrierA dynwin_i)  (* input *)
      (y : Vector.t CarrierA dynwin_o), (* output *)

      (* Evaluation of the source program.
         The program is fixed and hard-coded: the result is not generic,
         we provide a "framework". *)
      dynwin_orig a x = y →

      (* We cannot hide away the [R] level as we axiomatize the real to float
       approximation performed *)
      ∀ (dynwin_R_memory : RHCOL.memory)
        (dynwin_F_memory : memoryH)
        (dynwin_R_σ : RHCOLEval.evalContext)
        (dynwin_F_σ : evalContext)
        (dynwin_rhcol : RHCOL.DSHOperator)
        (dynwin_fhcol : FHCOL.DSHOperator),

        (* dynwin_AHCOL is a constant: it is generated by MetaCoq from dynwin_orig.
           This program is then translated down to the R level first, F level second.
           QUESTION : why don't we know the translations if the program is fixed?
         *)
        AHCOLtoRHCOL.translate dynwin_AHCOL = inr dynwin_rhcol →
        RHCOLtoFHCOL.translate dynwin_rhcol = inr dynwin_fhcol →

        (* [build_dynwin_memory] constructs the A-level initial memory
           This initial memory is translated successively down to R and F.
           QUESTION : can the translation fail for some a/x?
         *)
        AHCOLtoRHCOL.translate_runtime_memory (build_dynwin_memory a x) = inr dynwin_R_memory →
        RHCOLtoFHCOL.translate_runtime_memory dynwin_R_memory           = inr dynwin_F_memory →

        (* [build_dynwin_σ] constructs the A-level initial environment
           This initial environment is translated successively down to R and F.
           QUESTION : why don't we know the translations if the program is fixed?
         *)
        AHCOLtoRHCOL.translateEvalContext build_dynwin_σ = inr dynwin_R_σ →
        RHCOLtoFHCOL.translateEvalContext dynwin_R_σ     = inr dynwin_F_σ →

        (* The content of the blocks at the R level where [a] and [y] are stored.
           QUESTION : why don't we know the translations if the program is fixed?
         *)
        ∀ a_rmem x_rmem : RHCOLEval.mem_block,
          RHCOLEval.memory_lookup dynwin_R_memory dynwin_a_addr = Some a_rmem →
          RHCOLEval.memory_lookup dynwin_R_memory dynwin_x_addr = Some x_rmem →

          (* ?? *)
          InConstr a_rmem x_rmem →

          (* At the R-level, there are a memory and a memory block st... *)
          ∃ (r_omemory : RHCOLEval.memory) (y_rmem : RHCOLEval.mem_block),

            (* Evaluation succeeds and returns this memory *)
            RHCOLEval.evalDSHOperator dynwin_R_σ dynwin_rhcol dynwin_R_memory (RHCOLEval.estimateFuel dynwin_rhcol) = Some (inr r_omemory) ∧

            (* At the expected [y] address is found the memory block *)
              RHCOLEval.memory_lookup r_omemory dynwin_y_addr = Some y_rmem ∧

            (* And this memory block is precisely the translation of y *)
              AHCOLtoRHCOL.translate_runtime_mem_block (MSigmaHCOL.MMSCHOL.avector_to_mem_block y) = inr y_rmem ∧

              (* At the F-level, there are a memory and a memory block st... *)
              (∃ (f_omemory : memoryH) (y_fmem : mem_block),

                  (* Evaluation succeeds and returns this memory *)
                  evalDSHOperator dynwin_F_σ dynwin_fhcol dynwin_F_memory (estimateFuel dynwin_fhcol) = Some (inr f_omemory) ∧

                    (* At the expected [y] address is found the memory block *)
                    memory_lookup f_omemory dynwin_y_addr = Some y_fmem ∧

                    (* And this memory block is related to the R version *)
                    OutRel a_rmem x_rmem y_rmem y_fmem)

.
  intros.
  eapply HCOL_to_FHCOL_Correctness; eauto.
Qed.

(* TODO *)
Section Program.

  Local Obligation Tactic := cbv;auto.
  Program Definition dynwin_i' : Int64.int := Int64.mkint (Z.of_nat dynwin_i) _.
  Program Definition dynwin_o' : Int64.int := Int64.mkint (Z.of_nat dynwin_o) _.

  (* TODO pull and recompile?? *)
  (* TODO convert R global type signature to F global type signature? *)
  Definition dynwin_globals' : list (string * FHCOL.DSHType).
    (* refine (_ dynwin_FHCOL_globals). *)
  Admitted.

  (* Here I should be able to compute the operator instead of quantifying over it in the statement *)
  Definition dynwin_fhcolp : FHCOL.DSHOperator -> FSHCOLProgram :=
    mkFSHCOLProgram dynwin_i' dynwin_o' "dyn_win" dynwin_globals'.

  (* Where do I build my data to pass to compile_w_main? *)
  (* Lookup in fmem yaddr xaddr and aaddr and flatten *)
  Definition dynwin_data (a_fmem x_fmem : FHCOLEval.mem_block): list binary64.
  Admitted.

End Program.

(* (* with init step  *) *)
(* Lemma compiler_correct_aux: *)
(*   forall (p:FSHCOLProgram) *)
(*     (data:list binary64) *)
(*     (pll: toplevel_entities typ (LLVMAst.block typ * list (LLVMAst.block typ))), *)
(*     forall s, compile_w_main p data newState ≡ inr (s,pll) -> *)
(*     eutt (succ_mcfg (bisim_full nil s)) (semantics_FSHCOL p data) (semantics_llvm pll). *)
(* Proof. *)
(*   intros * COMP. *)
(*   unshelve epose proof memory_invariant_after_init _ _ (conj _ COMP) as INIT_MEM. *)
(*   helix_initial_memory *)
(*   unfold compile_w_main,compile in COMP. *)
(*   cbn* in COMP. *)
(*   simp. *)
(*   unshelve epose proof @compile_FSHCOL_correct _ _ _ (* dynwin_F_σ dynwin_F_memory *) _ _ _ _ _ _ _ _ _ Heqs _ _ _ _. *)

Set Nested Proofs Allowed.
Import MonadNotation.
Local Open Scope monad_scope.
Import ListNotations.

(* Definition helix_initializer (p:FSHCOLProgram) (data:list binary64) *)
(*   : itree Event (nat*nat) := *)
(*   '(data, σ) <- denote_initFSHGlobals data p.(Data.globals) ;; *)
(*   xindex <- trigger (MemAlloc p.(i));; *)
(*   yindex <- trigger (MemAlloc p.(o));; *)
(*   let '(data, x) := constMemBlock (MInt64asNT.to_nat p.(i)) data in *)
(*   trigger (MemSet xindex x);; *)
(*   Ret (xindex,yindex). *)

Definition helix_finalizer (p:FSHCOLProgram) (yindex : nat)
  : itree Event _ :=
  bk <- trigger (MemLU "denote_FSHCOL" yindex);;
  lift_Derr (mem_to_list "Invalid output memory block" (MInt64asNT.to_nat p.(o)) bk).

(* Replacement for [denote_FSHCOL] where the memory is shallowy initialized using [helix_initial_memory].
   In this setup, the address at which [x] and [y] are allocated in memory is explicitly hard-coded rather than relying on the exact behavior of [Alloc].
 *)
Definition denote_FSHCOL' (p:FSHCOLProgram) (data:list binary64)
  : itree Event (list binary64) :=
  '(hmem,hdata,σ) <- lift_Derr (helix_initial_memory p data);;
  let xindex := List.length p.(globals) in
  let yindex := S xindex in
  let σ := List.app σ
                    [(DSHPtrVal yindex p.(o),false);
                     (DSHPtrVal xindex p.(i),false)]
  in
  denoteDSHOperator σ (p.(Data.op) : DSHOperator);;
  helix_finalizer p yindex.

Definition semantics_FSHCOL' (p: FSHCOLProgram) (data : list binary64)
  : failT (itree E_mcfg) (memoryH * list binary64) :=
  interp_helix (denote_FSHCOL' p data) memory_empty.

(* TODO
   We want to express that the computed value is the right one
   Confused: compile with main returns the content of the [y] global.
   Is that the data or the address of the data in memory?
   The former makes little sense to me, but the latter even less as we are looking for a vector.
 *)
Definition final_rel_val : list binary64 -> uvalue -> Prop :=
  fun vh vv => vv ≡ UVALUE_Array (List.map UVALUE_Double vh).

Definition final_rel : Rel_mcfg_OT (list binary64) uvalue :=
  succ_mcfg (fun '(_,vh) '(_,(_,(_,vv))) => final_rel_val vh vv).

(* TODO:
   Why does [helix_initial_memory p data] succeeds?
 *)
(* helix_initial_memory is actually pure!! *)
Lemma compiler_correct_aux:
  forall (p:FSHCOLProgram)
    (data:list binary64)
    (pll: toplevel_entities typ (LLVMAst.block typ * list (LLVMAst.block typ))),
  forall s hmem hdata σ,
    helix_initial_memory p data ≡ inr (hmem, hdata, σ) ->
    compile_w_main p data newState ≡ inr (s,pll) ->
    eutt final_rel (semantics_FSHCOL' p data) (semantics_llvm pll).
Proof.
  intros * INIT COMP.
  pose proof memory_invariant_after_init _ _ (conj INIT COMP) as INIT_MEM.
  unfold compile_w_main,compile in COMP.
  cbn* in COMP.
  simp.
  (* unshelve epose proof @compile_FSHCOL_correct _ _ _ (* dynwin_F_σ dynwin_F_memory *) _ _ _ _ _ _ _ _ _ Heqs _ _ _ _. *)
Admitted.



(* Lemma helix_inital_memory_denote_initFSHGlobals : *)
(*   forall p data        (* FSHCOL static data  *) *)
(*     hmem hdata σ  (* FSHCOL dynamic data *), *)
(*     helix_initial_memory p data = inr (hmem,hdata,σ) -> (* shallow memory initialization *) *)
(*     interp_helix (initial_memory_intra . ...) ? ? \eutt Ret (hmem,hdata,σ). *)


Lemma top_to_LLVM :
  (* refine ( *)
      forall (H : orders.SemiRingOrder CarrierAle)

        (AR_CHE : AHCOLtoRHCOL.CTranslation_heq)
        (AR_CTO : AHCOLtoRHCOL.CTranslationOp)
        (* (AR_NHE : AHCOLtoRHCOL.NTranslation_heq) *)
        (* (AR_NTO : AHCOLtoRHCOL.NTranslationOp) *)

        (* (H1: AHCOLtoRHCOL.NTranslationProps) *)
        (* (H2: AHCOLtoRHCOL.NOpTranslationProps) *)
        (H3: AHCOLtoRHCOL.CTranslationOp_strict)
        (H4: AHCOLtoRHCOL.COpTranslationProps)

        (RF_CHE : RHCOLtoFHCOL.CTranslation_heq)
        (RF_CTO : RHCOLtoFHCOL.CTranslationOp)

        (a : Vector.t CarrierA 3) (* ? *)
        (x : Vector.t CarrierA dynwin_i)  (* input *)
        (y : Vector.t CarrierA dynwin_o) (* output *)

        (* Evaluation of the source program.
         The program is fixed and hard-coded: the result is not generic,
         we provide a "framework". *)
        (EVAL : dynwin_orig a x = y)

        (* We cannot hide away the [R] level as we axiomatize the real to float
       approximation performed *)
        (dynwin_R_memory : RHCOL.memory)
        (dynwin_F_memory : memoryH)
        (dynwin_R_σ : RHCOLEval.evalContext)
        (dynwin_F_σ : evalContext)
        (dynwin_rhcol : RHCOL.DSHOperator)
        (dynwin_fhcol : FHCOL.DSHOperator)

        (TR1 : AHCOLtoRHCOL.translate dynwin_AHCOL = inr dynwin_rhcol)
        (TR2 : RHCOLtoFHCOL.translate dynwin_rhcol = inr dynwin_fhcol)

        (TR3 : AHCOLtoRHCOL.translate_runtime_memory (build_dynwin_memory a x) = inr dynwin_R_memory)
        (TR4 : RHCOLtoFHCOL.translate_runtime_memory dynwin_R_memory           = inr dynwin_F_memory)

        (TR5 : AHCOLtoRHCOL.translateEvalContext build_dynwin_σ = inr dynwin_R_σ)
        (TR6 : RHCOLtoFHCOL.translateEvalContext dynwin_R_σ     = inr dynwin_F_σ)

        (a_rmem x_rmem y_rmem : RHCOLEval.mem_block)
        (LU1 : RHCOLEval.memory_lookup dynwin_R_memory dynwin_a_addr = Some a_rmem)
        (LU2 : RHCOLEval.memory_lookup dynwin_R_memory dynwin_x_addr = Some x_rmem)
        (* I need y_rmem for the data, but it should be existentially returned... *)
        (LU3 : RHCOLEval.memory_lookup dynwin_R_memory dynwin_y_addr = Some y_rmem)

        (INC: InConstr a_rmem x_rmem)

        (* START OF LLVM-level stuff *)
        s pll hmem hdata σ JOKERa
        (COMP  : compile_w_main (dynwin_fhcolp dynwin_fhcol) JOKERa (* (dynwin_data a) *) newState ≡ inr (s,pll))
        (HINIT : helix_initial_memory (dynwin_fhcolp dynwin_fhcol) JOKERa (* (dynwin_data a) *) ≡ inr (hmem, hdata, σ))
      ,
      exists g l m r JOKER, semantics_llvm pll ≡ Ret (m,(l,(g, r))) /\
                   final_rel_val (JOKER y) r.

  intros.

  (* The current statement gives us essentially FHCOL-level inputs and outputs, and relate them to the source *)
  edestruct top_to_FHCOL as (r_omemory & y_rmem' & EVR & LUR & TRR & f_omemory & y_fmem & EVF & LUF & TRF); eauto.

  (* TODO : evaluation in terms of equiv and not eq, contrary to what' assumed in EvalDenoteEquiv.
     Is it an easy fix to Denote_Eval_Equiv?
   *)
  match type of EVF with
  | ?x = ?y => clear EVF; assert (EVF:x ≡ y) by admit
  end.
  (* We know that we can see the evaluation of the FHCOL operator under an itree-lense  *)
  pose proof (Denote_Eval_Equiv _ _ _ _ _ EVF) as EQ.

  (* What are the llvm addresses that correspond to x y a?

exists memf,


   *)


  eapply compiler_correct_aux in COMP; try eassumption.

  clear - EQ EVF COMP HINIT.
helix_initial_memory
  unfold semantics_FSHCOL' in COMP.
  unfold denote_FSHCOL' in COMP.
  rewrite HINIT in COMP.
  cbn in COMP.
  rewrite bind_ret_l in COMP.
  (* TODO
     can we prove them to be the same? There's a constant around, might reduce.

     I'm completely lost about the status of [dynwin_F_σ] that comes from the translation of the dynamic context at the level above and [σ] that results from the initialization phase [helix_initial_memory]
   *)


  unfold dynwin_F_σ in EQ.

  assert (interp_helix 

  rewrite interp_helix_bind in COMP.


  unfold interp_helix in COMP.

  forall (p:FSHCOLProgram)
    (data:list binary64)
    (pll: toplevel_entities typ (LLVMAst.block typ * list (LLVMAst.block typ))),
    forall s, compile_w_main p data newState ≡ inr (s,pll) ->
    eutt (succ_mcfg (bisim_full [] s)) (semantics_FSHCOL p data) (semantics_llvm pll).
Proof.
Abort.


  (* Inverting the success of compile_w_main to relate to the successful compilation of the underlying
     operator. Will be pulled out as a lemma.
   *)
  clear -COMP EQ.
  cbn* in COMP.
  simp.

  (* Now we know that the compilation of operators is correct *)
  epose proof @compile_FSHCOL_correct _ _ _ dynwin_F_σ dynwin_F_memory _ _ _ _ _ _ _ Heqs _ _ _ _.
